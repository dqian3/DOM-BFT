syntax = "proto3";
package dombft.proto;

message ClientRequest {
    uint32 client_id = 1;
    uint32 client_seq = 2;
    uint32 round = 3;
    uint32 pbft_view = 4;

    uint64 send_time = 5;
    bool is_write = 6;

    bytes req_data = 7;
    bytes padding = 8;
}

message DOMRequest {
    uint64  deadline = 1;
    uint64  send_time = 2;
    uint32  proxy_id = 3;
    bool    late = 4;
    uint32  deadline_set_size = 5;

    uint32  client_id = 6; // repeat client_id here for convenience in breaking ties
    uint32  client_seq = 7; // repeat client_seq here for debugging
    bytes   client_req = 8; // Bytes of Client Request + Signature
}

message MeasurementReply {
    uint32 receiver_id = 1;
    int32 owd = 2;
    uint64 send_time = 3;
}

message Reply {
    uint32 client_id = 1;
    uint32 client_seq = 2;

    uint32 round = 3;

    // Tentative global ordering
    uint32 seq = 5;
    uint32 replica_id = 6;
    bytes result = 9;
    bytes digest = 10;
}

message Cert {
    // A cert logically is a set of 2f + 1 replies
    
    // TODO to save space, we would only store 1 copy of each common field. Instead
    // we just repeat them here since it's easier
    // seq is also just for convenience
    uint32 seq = 1;
    uint32 round = 2;
    
    repeated Reply replies    = 4;
    repeated bytes signatures = 5;
}


message CertReply {
    uint32 replica_id = 1;
    uint32 client_id = 2;
    uint32 client_seq = 3;
    uint32 round = 4;
    uint32 seq = 5;
}

message Commit {
    uint32 replica_id = 1;
    uint32 round = 2;
    uint32 seq = 3;

    bytes log_digest = 5;
    bytes app_digest = 6;

    ClientRecord client_record = 8;
}

message RepairClientTimeout
{

    uint32 client_id = 1;
    uint32 client_seq = 2;

    uint32 round = 3;

    // could add request here too, but we do not
}

message RepairReplicaTimeout
{
    uint32 round = 1;
    uint32 replica_id = 2;
}

message RepairTimeoutProof {
    uint32 round = 1;

    repeated RepairReplicaTimeout timeouts = 2;
    repeated bytes signatures = 3;
}

message RepairReplyProof {
    uint32 client_id = 1;
    uint32 client_seq = 2;

    uint32 round = 3;

    repeated Reply replies = 4;
    repeated bytes signatures = 5;
}


message LogEntry
{
    uint32 seq = 4;
    uint32 client_id = 5;
    uint32 client_seq = 6;

    bytes digest = 7;

    // TODO is this needed?
    bytes request = 8;
    bytes result = 9;
}

message ClientSequence
{
    uint32 client_id = 1;
    uint32 last_seq = 2;

    repeated uint32 missed_seqs = 3;
}

// wraps records and digest
message ClientRecord
{
    bytes digest = 1;
    repeated ClientSequence sequences = 2;
}

message LogCheckpoint
{
    uint32 seq = 1;
    bytes app_digest = 2;
    bytes log_digest = 3;

    repeated Commit commits   = 5;
    repeated bytes signatures = 6;
    Cert cert = 7;

    ClientRecord client_record = 8;
}


message RepairStart
{
    uint32 pbft_view = 1;
    uint32 round = 2;
    uint32 replica_id = 3;

    repeated LogEntry log_entries = 4;
    LogCheckpoint checkpoint = 5;
    
    optional Cert cert = 7;
}

message RepairProposal
{
    uint32 round = 1;
    uint32 replica_id = 2; //primary id

    repeated RepairStart logs = 3;
    repeated bytes signatures = 4;
}


message CommittedReply
{
    uint32 replica_id = 1;
    uint32 client_id = 2;
    uint32 client_seq = 3;
    uint32 seq = 4;
    bytes result = 5;
}

message RepairSummary
{
    uint32 round = 1;
    uint32 replica_id = 2;
    repeated CommittedReply replies = 3;
    uint32 pbft_view = 4;
}

message PBFTPrePrepare
{
    uint32 round = 1;
    uint32 primary_id = 2;
    uint32 pbft_view= 3;

    RepairProposal proposal = 4;
    bytes proposal_digest = 5;
}

message PBFTPrepare
{
    uint32 round = 1;
    uint32 replica_id = 2;
    uint32 pbft_view= 3;
    bytes proposal_digest = 4;
}

message PBFTCommit
{
    uint32 round = 1;
    uint32 replica_id = 2;
    uint32 pbft_view= 3;
    bytes proposal_digest = 4;
}

message PBFTViewChange
{
    uint32 round = 1;
    uint32 replica_id = 2;
    uint32 pbft_view= 3;
    repeated  PBFTPrepare prepares = 4;
    repeated  bytes prepare_sigs = 5;
    // we add the "request" for simplicity though PBFT use fetching when the request is missing
    RepairProposal proposal = 6;
    bytes proposal_digest = 7;
}

message PBFTNewView
{
    uint32 primary_id = 1;
    uint32 pbft_view= 2;
    uint32 round = 3;
    repeated PBFTViewChange view_changes = 4;
    repeated bytes view_change_sigs = 5;
}

message SnapshotRequest {
    uint32 round = 1;
    uint32 seq = 2;
    uint32 replica_id = 3;
    uint32 last_checkpoint_seq = 4;

    bool for_repair = 5;
}

message SnapshotReply {
    uint32 round = 1;
    uint32 seq = 2;
    uint32 replica_id = 3;
    uint32 pbft_view = 4;
    bytes snapshot = 5;
}

message DummyProtocolMessage
{
    uint32 phase = 1;
    uint32 replica_id = 2;
    uint32 seq = 3;

    uint32 client_id = 4;
    uint32 client_seq = 5;
}





