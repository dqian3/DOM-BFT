syntax = "proto3";
package dombft.proto;

message ClientRequest {
    uint32 client_id = 1;
    uint32 client_seq = 2;
    uint32 instance = 3;
    uint32 pbft_view = 4;

    uint64 send_time = 5;
    bool is_write = 6;

    bytes req_data = 7;
}

message DOMRequest {
    uint64  deadline = 1;
    uint64  send_time = 2;
    uint32  proxy_id = 3;
    bool    late = 4;
    uint32  deadline_set_size = 5;

    uint32  client_id = 6; // repeat client_id here for convenience in breaking ties
    uint32  client_seq = 7; // repeat client_seq here for debugging
    bytes   client_req = 8; // Bytes of Client Request + Signature
}

message MeasurementReply {
    uint32 receiver_id = 1;
    int32 owd = 2;
    uint64 send_time = 3;
}

message Reply {
    uint32 client_id = 1;
    uint32 client_seq = 2;

    // Tentative global ordering
    uint32 instance = 3;
    uint32 pbft_view = 4;
    uint32 seq = 5;

    uint32 replica_id = 6;
    bool fast = 7;
    bool retry = 8;
    bytes result = 9;
    bytes digest = 10;
}

message Cert {
    // A cert logically is a set of 2f + 1 replies
    
    // TODO to save space, we would only store 1 copy of each common field. Instead
    // we just repeat them here since it's easier
    // seq is also just for convenience
    uint32 seq = 1;
    uint32 instance = 2;
    uint32 pbft_view = 3;
    
    repeated Reply replies    = 4;
    repeated bytes signatures = 5;
}


message CertReply {
    uint32 replica_id = 1;
    uint32 client_id = 2;
    uint32 client_seq = 3;
    uint32 instance = 4;
    uint32 pbft_view = 5;
    uint32 seq = 6;
}

message Commit {
    uint32 replica_id = 1;
    uint32 instance = 2;
    uint32 seq = 3;

    bytes log_digest = 4;
    bytes app_digest = 5;
    CheckpointClientRecordsSet client_records_set = 6;
}

message FallbackTrigger
{
    uint32 client_id = 1;
    uint32 client_seq = 2;
    uint32 instance = 3;
    uint32 pbft_view = 4;
    bytes req_data = 5;
    // Reuse Cert message here, since it is just a set of replies.
    optional Cert proof =6;
}

message CheckpointClientRecord
{
    uint32 client_id = 1;
    uint32 instance = 2;
    uint32 last_seq = 3;

    repeated uint32 missed_seqs = 4;
}

// wraps records and digest
message CheckpointClientRecordsSet
{
    bytes client_records_digest = 1;
    repeated CheckpointClientRecord records = 2;
}

message LogEntry
{
    uint32 seq = 4;
    uint32 client_id = 5;
    uint32 client_seq = 6;

    bytes digest = 7;

    // TODO is this needed?
    bytes request = 8;
    bytes result = 9;

    optional Cert cert = 10;
}


message LogCheckpoint
{
    uint32 seq = 4;
    bytes app_digest = 5;
    bytes log_digest = 6;

    repeated Commit commits   = 7;
    repeated bytes signatures = 8;
    Cert cert = 10;
}


message FallbackStart
{
    uint32 pbft_view = 1;
    uint32 instance = 2;
    uint32 replica_id = 3;

    repeated LogEntry log_entries = 4;
    LogCheckpoint checkpoint = 5;
    CheckpointClientRecordsSet client_records_set = 6;
}

message FallbackProposal
{
    uint32 instance = 1;
    uint32 replica_id = 2; //primary id

    repeated FallbackStart logs = 3;
    repeated bytes signatures = 4;
}


message FallbackReply
{
    uint32 client_id = 1;
    uint32 client_seq = 2;
    uint32 seq = 3;
    bytes result = 4;
}

message FallbackSummary
{
    uint32 instance = 1;
    uint32 replica_id = 2;
    repeated FallbackReply replies = 3;
    uint32 pbft_view = 4;
}

message PBFTPrePrepare
{
    uint32 instance = 1;
    uint32 primary_id = 2;
    uint32 pbft_view= 3;

    FallbackProposal proposal = 4;
    bytes proposal_digest = 5;
}

message  PBFTPrepare
{
    uint32 instance = 1;
    uint32 replica_id = 2;
    uint32 pbft_view= 3;
    bytes proposal_digest = 4;
}

message PBFTCommit
{
    uint32 instance = 1;
    uint32 replica_id = 2;
    uint32 pbft_view= 3;
    bytes proposal_digest = 4;
}

message PBFTViewChange
{
    uint32 instance = 1;
    uint32 replica_id = 2;
    uint32 pbft_view= 3;
    repeated  PBFTPrepare prepares = 4;
    repeated  bytes prepare_sigs = 5;
    // we add the "request" for simplicity though PBFT use fetching when the request is missing
    FallbackProposal proposal = 6;
    bytes proposal_digest = 7;
}

message PBFTNewView
{
    uint32 primary_id = 1;
    uint32 pbft_view= 2;
    uint32 instance = 3;
    repeated PBFTViewChange view_changes = 4;
    repeated bytes view_change_sigs = 5;
}

message DummyProtocolMessage
{
    uint32 phase = 1;
    uint32 replica_id = 2;
    uint32 seq = 3;

    uint32 client_id = 4;
    uint32 client_seq = 5;
}





